// <copyright file="BaseGenerator.cs" company="Allied Bits Ltd.">
//
// Copyright 2025 Allied Bits Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// </copyright>

using System.Text;

namespace Tlumach.Base
{
#pragma warning disable CA1510 // Use 'ArgumentNullException.ThrowIfNull' instead of explicitly throwing a new exception instance

    /// <summary>
    /// Includes core functions that generate the C# source code.
    /// </summary>
    public class BaseGenerator
    {
        private static string OwnName(string keyName)
        {
#pragma warning disable CA1307 // '...' has a method overload that takes a 'StringComparison' parameter. Replace this call ... for clarity of intent.
            int idx = keyName.IndexOf('.');
#pragma warning restore CA1307 // '...' has a method overload that takes a 'StringComparison' parameter. Replace this call ... for clarity of intent.

            if (idx == -1)
                return keyName;
            else
            if (idx == keyName.Length - 1)
                return string.Empty;
            else
                return keyName.Substring(idx + 1);
        }

        protected BaseGenerator()
        {
            // this constructor does nothing
        }

        protected static string? GenerateClass(string configFile, string projectDir, string usingNamespace)
        {
            if (configFile is null)
                throw new ArgumentNullException(nameof(configFile));

            string? dirName = Path.GetDirectoryName(configFile);

            // if (dirName)

            TranslationConfiguration? configuration;

            // The config parser will parse configuration and will find the correct parser for the files referenced by the configuration
            BaseFileParser? parser = FileFormats.GetConfigParser(Path.GetExtension(configFile));
            if (parser is null)
                return null;

            TranslationTree? translationTree = parser.LoadTranslationStructure(configFile, projectDir, out configuration);

            if (configuration is null)
                throw new ParserLoadException(configFile, $"Failed to load the configuration from '{configFile}'");

            if (translationTree is null)
                throw new ParserLoadException(configFile, $"Failed to load the default language file referenced by '{configFile}'");

            // We have these checks here because a parser's ValidateConfiguration method accepts empty values (they are ok in runtime or when generators are not used).
            if (string.IsNullOrEmpty(configuration.Namespace))
                throw new ParserConfigException(configFile, $"The configuration file '{configFile}' does not contain a namespace for the class to be generated, which must be specified in the '{TranslationConfiguration.KEY_GENERATED_NAMESPACE}' setting");

            if (string.IsNullOrEmpty(configuration.ClassName))
                throw new ParserConfigException(configFile, $"The configuration file '{configFile}' does not contain a name of the class to be generated, which must be specified in the '{TranslationConfiguration.KEY_GENERATED_CLASS}' setting");

            StringBuilder builder = new();

            EmitMainBody(builder, usingNamespace, configuration, translationTree);

            return builder.ToString();
        }

        private static void EmitMainBody(StringBuilder builder, string usingNamespace, TranslationConfiguration configuration, TranslationTree translationTree)
        {
            builder.Append("// ").AppendLine(configuration.DefaultFile);
            builder.AppendLine("// <auto-generated/>\n");
            builder.AppendLine("using System;\nusing System.Reflection;\n");
            builder.AppendLine("using Tlumach.Base;");
            if (!(string.IsNullOrEmpty(usingNamespace) || usingNamespace.Equals("Tlumach", StringComparison.Ordinal)))
                builder.Append("using ").Append(usingNamespace).AppendLine(";");
            builder.AppendLine("using Tlumach;\n");
            builder.Append("namespace ").Append(configuration.Namespace).AppendLine(";");
            builder.AppendLine();
            builder.Append("public static class ").AppendLine(configuration.ClassName);
            builder.AppendLine("{");
            if (!string.IsNullOrEmpty(configuration.DefaultFileLocale))
                builder.Append("    private static string? _defaultFileLocale = \"").Append(configuration.DefaultFileLocale).AppendLine("\";");
            else
                builder.AppendLine("    private static string? _defaultFileLocale = null;");
            builder.AppendLine();
            builder.Append("    private static TranslationConfiguration _translationConfiguration = new TranslationConfiguration(typeof(").Append(configuration.ClassName).Append(").Assembly, \"").Append(configuration.DefaultFile).Append("\", _defaultFileLocale, ").Append(configuration.GetTemplateEscapeModeFullName()).AppendLine(");\n");

            if (configuration.Translations.Count > 0)
            {
                builder.Append("    static ").Append(configuration.ClassName).AppendLine("()");
                builder.AppendLine("    {");
                foreach (var translation in configuration.Translations)
                {
                    builder.Append("        _translationConfiguration.Translations.Add(\"").Append(translation.Key).Append("\", @\"").Append(translation.Value).AppendLine("\");");
                }

                builder.AppendLine("    }\n");
            }

            builder.AppendLine("    ///<summary>");
            builder.AppendLine("    ///Use this instance to change the default culture or to access translations without using TranslationUnit instances");
            builder.AppendLine("    ///</summary>");
            builder.AppendLine("    public static TranslationManager TranslationManager {get; } = new TranslationManager(_translationConfiguration);\n");

            EmitGroupUnits(builder, translationTree, translationTree.RootNode, 1, usingNamespace, string.Empty);

            builder.AppendLine("}");
        }

        private static void EmitGroupUnits(StringBuilder builder, TranslationTree translationTree, TranslationTreeNode node, int level, string @namespace, string namePrefix)
        {
            if (builder is null)
                throw new ArgumentNullException(nameof(builder));

            if (node is null)
                throw new ArgumentNullException(nameof(node));

            var indent = new string(' ', level << 2);

            TranslationTreeLeaf value;
            string unitClassName;

            bool groupStart = false;

            // The key here is a KeyValuePair, in which the key (and Value.Key) is the own name within the group.
            foreach (var key in node.Keys.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
            {
                value = key.Value;
                if (value.IsTemplated)
                    unitClassName = "TemplatedTranslationUnit";
                else
                    unitClassName = "TranslationUnit";

                if (@namespace.Length > 0)
                {
                    unitClassName = @namespace + "." + unitClassName;
                }

                if (groupStart)
                    builder.AppendLine();
                groupStart = true;
                builder.Append(indent)
                    .Append("public static readonly ").Append(unitClassName).Append(' ').Append(OwnName(value.Key))
                    .Append(" = new ").Append(unitClassName).Append("(TranslationManager, _translationConfiguration, \"").Append(namePrefix + value.Key).AppendLine("\");");
            }

            string subKey;
            foreach (var child in node.ChildNodes.Keys.OrderBy(x => x, StringComparer.OrdinalIgnoreCase))
            {
                subKey = node.ChildNodes[child].Name;

                if (groupStart)
                    builder.AppendLine();
                groupStart = true;

                builder.Append(indent).Append("public static class ").AppendLine(subKey);
                builder.Append(indent).AppendLine("{");
                EmitGroupUnits(builder, translationTree, node.ChildNodes[child], level + 1, @namespace, namePrefix + subKey + '.');
                builder.Append(indent).AppendLine("}");
            }
        }
    }
}
